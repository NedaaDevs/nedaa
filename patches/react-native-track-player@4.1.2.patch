diff --git a/android/src/main/java/com/doublesymmetry/trackplayer/module/MusicModule.kt b/android/src/main/java/com/doublesymmetry/trackplayer/module/MusicModule.kt
index b2409a09939164c49c0f7a16bb6d3284e8eab8fb..fee72e1944273e778650193aaca298f21600a5eb 100644
--- a/android/src/main/java/com/doublesymmetry/trackplayer/module/MusicModule.kt
+++ b/android/src/main/java/com/doublesymmetry/trackplayer/module/MusicModule.kt
@@ -251,7 +251,7 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
     }
 
     @ReactMethod
-    fun updateOptions(data: ReadableMap?, callback: Promise) = scope.launch {
+    fun updateOptions(data: ReadableMap?, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         val options = Arguments.toBundle(data)
@@ -261,10 +261,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         }
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun add(data: ReadableArray?, insertBeforeIndex: Int, callback: Promise) = scope.launch {
+    fun add(data: ReadableArray?, insertBeforeIndex: Int, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         try {
@@ -282,10 +282,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         } catch (exception: Exception) {
             rejectWithException(callback, exception)
         }
-    }
+    } }
 
     @ReactMethod
-    fun load(data: ReadableMap?, callback: Promise) = scope.launch {
+    fun load(data: ReadableMap?, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         if (data == null) {
             callback.resolve(null)
@@ -298,17 +298,17 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         } else {
             callback.reject("invalid_track_object", "Track was not a dictionary type")
         }
-    }
+    } }
 
     @ReactMethod
-    fun move(fromIndex: Int, toIndex: Int, callback: Promise) = scope.launch {
+    fun move(fromIndex: Int, toIndex: Int, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         musicService.move(fromIndex, toIndex)
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun remove(data: ReadableArray?, callback: Promise) = scope.launch {
+    fun remove(data: ReadableArray?, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         val inputIndexes = Arguments.toList(data)
         if (inputIndexes != null) {
@@ -328,10 +328,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
             musicService.remove(indexes)
         }
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun updateMetadataForTrack(index: Int, map: ReadableMap?, callback: Promise) =
+    fun updateMetadataForTrack(index: Int, map: ReadableMap?, callback: Promise) {
         scope.launch {
             if (verifyServiceBoundOrReject(callback)) return@launch
 
@@ -345,10 +345,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
 
                 callback.resolve(null)
             }
-        }
+        } }
 
     @ReactMethod
-    fun updateNowPlayingMetadata(map: ReadableMap?, callback: Promise) = scope.launch {
+    fun updateNowPlayingMetadata(map: ReadableMap?, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         if (musicService.tracks.isEmpty())
@@ -361,10 +361,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         }
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun clearNowPlayingMetadata(callback: Promise) = scope.launch {
+    fun clearNowPlayingMetadata(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         if (musicService.tracks.isEmpty())
@@ -372,18 +372,18 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
 
         musicService.clearNotificationMetadata()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun removeUpcomingTracks(callback: Promise) = scope.launch {
+    fun removeUpcomingTracks(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.removeUpcomingTracks()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun skip(index: Int, initialTime: Float, callback: Promise) = scope.launch {
+    fun skip(index: Int, initialTime: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.skip(index)
@@ -393,10 +393,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         }
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun skipToNext(initialTime: Float, callback: Promise) = scope.launch {
+    fun skipToNext(initialTime: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.skipToNext()
@@ -406,10 +406,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         }
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun skipToPrevious(initialTime: Float, callback: Promise) = scope.launch {
+    fun skipToPrevious(initialTime: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.skipToPrevious()
@@ -419,10 +419,10 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         }
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun reset(callback: Promise) = scope.launch {
+    fun reset(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.stop()
@@ -430,136 +430,136 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         musicService.clear()
 
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun play(callback: Promise) = scope.launch {
+    fun play(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.play()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun pause(callback: Promise) = scope.launch {
+    fun pause(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.pause()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun stop(callback: Promise) = scope.launch {
+    fun stop(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.stop()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun seekTo(seconds: Float, callback: Promise) = scope.launch {
+    fun seekTo(seconds: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.seekTo(seconds)
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun seekBy(offset: Float, callback: Promise) = scope.launch {
+    fun seekBy(offset: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.seekBy(offset)
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun retry(callback: Promise) = scope.launch {
+    fun retry(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.retry()
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun setVolume(volume: Float, callback: Promise) = scope.launch {
+    fun setVolume(volume: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.setVolume(volume)
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun getVolume(callback: Promise) = scope.launch {
+    fun getVolume(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getVolume())
-    }
+    } }
 
     @ReactMethod
-    fun setRate(rate: Float, callback: Promise) = scope.launch {
+    fun setRate(rate: Float, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.setRate(rate)
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun getRate(callback: Promise) = scope.launch {
+    fun getRate(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getRate())
-    }
+    } }
 
     @ReactMethod
-    fun setRepeatMode(mode: Int, callback: Promise) = scope.launch {
+    fun setRepeatMode(mode: Int, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.setRepeatMode(RepeatMode.fromOrdinal(mode))
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun getRepeatMode(callback: Promise) = scope.launch {
+    fun getRepeatMode(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getRepeatMode().ordinal)
-    }
+    } }
 
     @ReactMethod
-    fun setPlayWhenReady(playWhenReady: Boolean, callback: Promise) = scope.launch {
+    fun setPlayWhenReady(playWhenReady: Boolean, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         musicService.playWhenReady = playWhenReady
         callback.resolve(null)
-    }
+    } }
 
     @ReactMethod
-    fun getPlayWhenReady(callback: Promise) = scope.launch {
+    fun getPlayWhenReady(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.playWhenReady)
-    }
+    } }
 
     @ReactMethod
-    fun getTrack(index: Int, callback: Promise) = scope.launch {
+    fun getTrack(index: Int, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         if (index >= 0 && index < musicService.tracks.size) {
-            callback.resolve(Arguments.fromBundle(musicService.tracks[index].originalItem))
+            callback.resolve(Arguments.fromBundle(musicService.tracks[index].originalItem!!))
         } else {
             callback.resolve(null)
         }
-    }
+    } }
 
     @ReactMethod
-    fun getQueue(callback: Promise) = scope.launch {
+    fun getQueue(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(Arguments.fromList(musicService.tracks.map { it.originalItem }))
-    }
+    } }
 
     @ReactMethod
-    fun setQueue(data: ReadableArray?, callback: Promise) = scope.launch {
+    fun setQueue(data: ReadableArray?, callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         try {
@@ -569,61 +569,61 @@ class MusicModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaM
         } catch (exception: Exception) {
             rejectWithException(callback, exception)
         }
-    }
+    } }
 
     @ReactMethod
-    fun getActiveTrackIndex(callback: Promise) = scope.launch {
+    fun getActiveTrackIndex(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         callback.resolve(
             if (musicService.tracks.isEmpty()) null else musicService.getCurrentTrackIndex()
         )
-    }
+    } }
 
     @ReactMethod
-    fun getActiveTrack(callback: Promise) = scope.launch {
+    fun getActiveTrack(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         callback.resolve(
             if (musicService.tracks.isEmpty()) null
             else Arguments.fromBundle(
-                musicService.tracks[musicService.getCurrentTrackIndex()].originalItem
+                musicService.tracks[musicService.getCurrentTrackIndex()].originalItem!!
             )
         )
-    }
+    } }
 
     @ReactMethod
-    fun getDuration(callback: Promise) = scope.launch {
+    fun getDuration(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getDurationInSeconds())
-    }
+    } }
 
     @ReactMethod
-    fun getBufferedPosition(callback: Promise) = scope.launch {
+    fun getBufferedPosition(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getBufferedPositionInSeconds())
-    }
+    } }
 
     @ReactMethod
-    fun getPosition(callback: Promise) = scope.launch {
+    fun getPosition(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
 
         callback.resolve(musicService.getPositionInSeconds())
-    }
+    } }
 
     @ReactMethod
-    fun getProgress(callback: Promise) = scope.launch {
+    fun getProgress(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         var bundle = Bundle()
         bundle.putDouble("duration", musicService.getDurationInSeconds());
         bundle.putDouble("position", musicService.getPositionInSeconds());
         bundle.putDouble("buffered", musicService.getBufferedPositionInSeconds());
         callback.resolve(Arguments.fromBundle(bundle))
-    }
+    } }
 
     @ReactMethod
-    fun getPlaybackState(callback: Promise) = scope.launch {
+    fun getPlaybackState(callback: Promise) { scope.launch {
         if (verifyServiceBoundOrReject(callback)) return@launch
         callback.resolve(Arguments.fromBundle(musicService.getPlayerStateBundle(musicService.state)))
-    }
+    } }
 }
